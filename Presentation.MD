# Motivation

How can it be possible for tests to have 100% coverage and still miss bugs?

Why is it that anytime we perform manual review we end up identifying combinations not covered by tests?

Is there a way to systematically identify and explore all smart contract combinations?

## Examples

- TODO: Add both motivating examples and a few bugs

## Coverage Classes

- Fully explained at this point, add SECRET if we can ship it in time

## External Coverage as part of our systems coverage

## Implied Lines

- msg.value causes balance to decrease, the code is in the node.

## Implied state

- `reentrant` state being the classic example

## Metaproperties

- Relation between 2 variables: [similar magnitude, 1 massively bigger than other]


## World splits

- Divisions causing no / negligible truncation
- Truncation causing significant invariants no longer holding
